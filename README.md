# Si_Lab2_195005

<h3>-2. Slika od cFG</h3><br>

2. ![cfg-195005](https://user-images.githubusercontent.com/73427967/119265071-abd99380-bbe5-11eb-9c4f-d173e3dcafe4.png)


3.  ![Screenshot 2021-09-14 133823](https://user-images.githubusercontent.com/73427967/133250945-8400af93-87aa-42bf-86c9-bd026569340a.png)
</br>
<h3> 3.- Presmetka od ciklimatska kompleksoost i objasnuvanje </h3>
<p> 3. Цикломамтската комплексност може да се одреди на два начина, броење на региони или наоѓање на колку имаме предикатни јазли и на тој број се додава 1 и резултатот на сето тоа ќе биде цикломатска комплексност. Предикатни јазли се јазловите каде што има гранење. Во графот кој го конструирав јас имам гранење во јазловите: B, D, E, G , I, J, L, M, O, Q, T. Бројот на јазли кај кои има гранење изнесува 11, на овој број додаваме +1 и добиваме (11+1) =12 . Цикломатска комплексност е 12. </p>
<br>

4. <h3> Да се напишат сите тест случаи според Multiple condition критериумот. Истите да се
напишат и објаснат во документацијата што се прикачува.  </h3>
Оваа метода налага да се евалуираат сите јазли во кои се врши
одлучување и тоа во двете можни насоки (true и false). Притоа треба да се
евалуираат сите можни комбинации за релационите изрази во јазлите за
обука. Треба да се има во предвид дека Lazy Evaluation ќе ги елиминира
некои од комбинациите на вистинитостите на релационите изрази


<br> [Si lab multiple.docx](https://github.com/fatxxj/Si_Lab2_195005/files/6528326/Si.lab.multiple.docx)

<br>

![MULTIPLE 195005](https://user-images.githubusercontent.com/73427967/119266199-20163600-bbea-11eb-9e2a-b76e73d5579a.png)


5.<h3> Да се напишат сите тест случаи според Every branch критериумот. Истите да се напишат
и објаснат во документацијата што се прикачува. </h3>
<br>
Every branch метода треба да тестира И услови, на пример ако влегол во иф-от да тестира  да тестира што се прави или што ке биде излез доколку не влегува во иф. Барем еден тест треба да ја опфаќа дадена гранка. Целта е ако првиот тест не ги покривал сите работи, вториот тест кој ке се прави треба тој сега да ги покрие сите работи. Во овој случај имам направено 9 тестови, можеби тоа не е оптимално но со сигурност ќе ги покрие сите гранки во кодот. Доколку едед тест покривал една гранка, не сум правил дополнителни провверки за таа гранка. 
[195005 - Every Branch.docx](https://github.com/fatxxj/Si_Lab2_195005/files/6528316/195005.-.Every.Branch.docx)

![everybranch 195005](https://user-images.githubusercontent.com/73427967/119265941-058f8d00-bbe9-11eb-9e61-966719f8a556.png)
<br>
<p> <h3> 6. Објаснение за напишаните тестови </h3> Унит тестовите ги напишав на начин што пробував да напишам се по малку тестови а со истите да ги опфаќам сите услови (multiple conditions) и сите гранки (Every branch). Во една функција во тест класата која се вика multipleConditionAndBranchTest , и во оваа функција има различни assert тестови. Секој од тие тестови ќе врака true доколку е фрлан соодветниот исклучок (доколку тестот е за да го провери исклучокот), со помош на assertTrue изрази тестирав дали  се довива соодетниот излез од тој дел од кодот каде се враќа вредност. Во кодот има коментари кои кажуваат со тој тест кој дел од кодот е покриен, кои гранки или услови или излези. Вкупно имам напишано 7 тестови, сите успешно се поминати. Кодот од тестови и самата класа може да се најде во src директориум во мојот GitHub профил </p>

<h1> Fat Halimi <i>195005</i></h1>
